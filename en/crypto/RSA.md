# RSA, RSA is encrypted and decrypted

## Introduction and description of harmony-utils

------
[harmony-utils](https://ohpm.openharmony.cn/#/cn/detail/@pura%2Fharmony-utils)A HarmonyOS tool library with rich features and extremely easy to use, with the help of many practical tools, is committed to helping developers quickly build Hongmeng applications. Its encapsulated tools cover APP, device, screen, authorization, notification, inter-thread communication, pop-up frames, toast, biometric authentication, user preferences, taking photos, albums, scanning codes, files, logs, exception capture, characters, strings, numbers, collections, dates, random, base64, encryption, decryption, JSON and other functions, which can meet various development needs.
[picker_utils](https://ohpm.openharmony.cn/#/cn/detail/@pura%2Fpicker_utils)It is a sub-store split by harmony-utils, including PickerUtil, PhotoHelper, and ScanUtil.

Download and install
`ohpm i @pura/harmony-utils`  
`ohpm i @pura/picker_utils`

 ```
  //全局初始化方法，在UIAbility的onCreate方法中初始化 AppUtil.init()
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    AppUtil.init(this.context);
  }
 ```


## Introduction to RSA algorithm

------
RSA is an asymmetric encryption algorithm proposed in 1977. Based on the design of large-number decomposition problem, the key is divided into public key (e,n) and private key (d,n), where n is the product of two prime numbers and d is the modulo inverse element of e. During encryption, the plain text m is generated by c=m^e mod n, and when decrypting, m=c^d mod n is used. Its security depends on the calculation complexity of decomposing large numbers n, and is often used in scenarios such as HTTPS key transmission and digital signatures. However, due to low computing efficiency, it is not suitable for encrypting large amounts of data, and the 1024-bit key can be threatened by quantum computing. It is now recommended that keys above 2048-bit are the pioneering algorithm of the public key encryption system.

## RSA application scenarios

------
As an asymmetric encryption algorithm, RSA is corely used in scenarios where public key verification and private key confidentiality are required. In network communication, HTTPS uses it to encrypt symmetric session keys and PGP to encrypt emails; in the field of digital signatures, it covers software code signatures, blockchain transaction authentication and electronic document signatures; in key management, it supports SSH password-free login and VPN key negotiation; in financial scenarios, the bank U-shield and CA certificate systems rely on them to achieve identity authentication and resistance. Although the calculation overhead is large and not suitable for massive data encryption, it is indispensable in key secure transmission and signature authentication, and is the basic algorithm of the Internet security system.


## API methods and usage

------

##### generateKeyPair generates asymmetric key KeyPair

```
let keyPair1 = await RSA.generateKeyPair();
let pubKeyStr1 = CryptoHelper.dataBlobToStr(keyPair1.pubKey.getEncoded(), 'hex'); //将公钥转换成base64字符串。
LogUtil.error(`pubKeyStr1: ${pubKeyStr1}`);
let priKeyStr1 = CryptoHelper.dataBlobToStr(keyPair1.priKey.getEncoded(), 'hex'); //将私钥转换成base64符符串。
LogUtil.error(`priKeyStr1: ${priKeyStr1}`);
```

##### getConvertKeyPair Get the converted asymmetric key KeyPair

```
let pubKeyStr = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDUpsnavHoapoKtOOM9NKqTt6BpPe07ZzxhMcLAm5dtFQ6zRyJwT3czHGnh1BM2FATvLTDGLkmKc/Ww27//lFbrbqBE19R/5y8UPRpbUdACZ28yqzdiaquovUndhTH/CnLzcPM7VnWO0gp3/kbg5WizkZtUTRHL+Nu4OHbbesO1wIDAQAB"; //base64字符串密钥
let priKeyStr = "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAMNSmydq8ehqmgq044z00qpO3oGk97TtnPGExwsCbl20VDrNHInBPdzMcaeHUEzYUBO8tMMYuSYpz9bDbv/+UVutuoETX1H/nLxQ9GltR0AJnbzKrN2Jqq6i9Sd2FMf8KcvNw8ztWdY7SCnf+RuDlaLORm1RNEcv427g4dtt6w7XAgMBAAECgYANvgsii9i3VIDADhgQe80ypFftYTD4btti9seWU7Z2K1Ddzj6axpjWpx+7/L4+md2Qde915pBoSfrQjnGJ21fX7vpqOVdDWS7lseYfM50z8ZMpZewxJNBkSGYQEazMYDfyCFMjZmB4guf/uu0B2JN/YtA8Ed7JJlkXmVLh4ReYSQJBAOIhzozpcIuGOBjylQdN+MokiL14gnAh6hiwnusD9JlTSJbQonUXkhikaf0WphxBVPSngZDdi3FYla/CDUAScBMCQQDdHwsJZ1oShtbJltaUCEsJHTWLwYm8V8tTOpHGJU8/u1mBK3pVZlwnfzzrj2oLl5iBpMHF197TPNi5gjrjM6atAkA/4pMrBixQjqu8iJQHy0R1P1sORER9j2dGcGeFN8nbo0bHrMuozu7sXU7APKzTILXypHwbRCvH6uHnFKiPqGXXAkAUsjEgQjImBcTYvWt8E4Kiab93QzgXDsiTE6pNN3TBbFGmS2F52MjLUZdsHNI6H4hAqiEQ2XGbp9hJFK1aUp1JAkEAjP4fbqrAUjGiG+EbjEffV625kACb6q9Wz+vbspMPqcr5TU2AxxSW65Yilq4pKYq8O+qXnVdOpX7DjrWA1kg2JA=="; //base64字符串密钥
let keyPair1 = await RSA.getConvertKeyPair(pubKeyStr, priKeyStr, 'base64');
let keyPair2 = RSA.getConvertKeyPairSync(pubKeyStr, priKeyStr, 'base64');
```

##### encrypt encryption

```
let keyPair1 = await RSA.generateKeyPair(); //生成密钥

let str1 = "鸿蒙技术交流QQ群：1029219059";
let dataBlob = CryptoHelper.strToDataBlob(str1, 'utf-8'); //待加密数据

let encryptDataBlob = await RSA.encrypt(dataBlob, keyPair1.pubKey); //加密
let encryptStr = CryptoHelper.dataBlobToStr(encryptDataBlob, 'utf-8');
LogUtil.error(`加密，异步：${encryptStr}`);
```

##### decrypt

```
let keyPair1 = await RSA.generateKeyPair(); //生成密钥

let str1 = "鸿蒙技术交流QQ群：1029219059";
let dataBlob = CryptoHelper.strToDataBlob(str1, 'utf-8'); //待加密数据

let encryptDataBlob = await RSA.encrypt(dataBlob, keyPair1.pubKey); //加密
let decryptDataBlob = await RSA.decrypt(encryptDataBlob, keyPair1.priKey); //解密
let decryptStr = CryptoHelper.dataBlobToStr(decryptDataBlob, 'utf-8');
LogUtil.error(`解密，异步：${decryptStr}`);or(`加解密，同步：${decryptStr2}`);
```

##### encryptSegment encryption, segmentation

```
let keyPair1 = await RSA.generateKeyPair("RSA1024|PRIMES_2"); //生成密钥

let str2 = "harmony-utils，一款高效的HarmonyOS工具包，封装了常用工具类，提供一系列简单易用的方法。帮助开发者快速构建鸿蒙应用。";
let dataBlob = CryptoHelper.strToDataBlob(str2, 'utf-8'); //待加密数据

let encryptDataBlob = await RSA.encryptSegment(dataBlob, keyPair1.pubKey, 'RSA2048|PKCS1'); //加密
let encryptStr = CryptoHelper.dataBlobToStr(encryptDataBlob, 'utf-8');
LogUtil.error(`分段加密，异步：${encryptStr}`);
```

##### decryptSegment decryption, segmentation

```
let keyPair1 = await RSA.generateKeyPair("RSA1024|PRIMES_2"); //生成密钥

let str2 = "harmony-utils，一款高效的HarmonyOS工具包，封装了常用工具类，提供一系列简单易用的方法。帮助开发者快速构建鸿蒙应用。";
let dataBlob = CryptoHelper.strToDataBlob(str2, 'utf-8'); //待加密数据

let encryptDataBlob = await RSA.encryptSegment(dataBlob, keyPair1.pubKey, 'RSA2048|PKCS1'); //加密
let decryptDataBlob = await RSA.decryptSegment(encryptDataBlob, keyPair1.priKey, 'RSA2048|PKCS1'); //解密
let decryptStr = CryptoHelper.dataBlobToStr(decryptDataBlob, 'utf-8');
LogUtil.error(`分段解密，异步：${decryptStr}`);
```

##### sign Sign the data

```
let keyPair = await RSA.generateKeyPair(); //生成密钥

let str1 = "鸿蒙技术交流QQ群：1029219059";
let dataBlob = CryptoHelper.strToDataBlob(str1, 'utf-8');

let signDataBlob1 = await RSA.sign(dataBlob, keyPair.priKey);
let signStr1 = CryptoHelper.dataBlobToStr(signDataBlob1, 'hex');
LogUtil.error(`签名，异步: ${signStr1}`);
```

##### verify the data verification

```
let keyPair = await RSA.generateKeyPair(); //生成密钥

let str1 = "鸿蒙技术交流QQ群：1029219059";
let signDataBlob1 = await RSA.sign(dataBlob, keyPair.priKey);
let signStr1 = CryptoHelper.dataBlobToStr(signDataBlob1, 'hex');

let verify1 = await RSA.verify(dataBlob, signDataBlob1, keyPair!.pubKey);
LogUtil.error(`验签，异步: ${verify1}`);
```

##### signSegment Signs the data in segmentation

```
let keyPair1 = await RSA.generateKeyPair(); //生成密钥

let str3 = "harmony-utils，一款高效的HarmonyOS工具包，封装了常用工具类，提供一系列简单易用的方法。帮助开发者快速构建鸿蒙应用。gitee地址：https://gitee.com/tongyuyan/harmony-utils。github主页地址：https://github.com/787107497。";
let data = CryptoHelper.strToUint8Array(str3, 'utf-8')；

let signDataBlob = await RSA.signSegment(data, keyPair.priKey);
let signStr = CryptoHelper.dataBlobToStr(signDataBlob, 'base64');
LogUtil.error(`分段签名，异步: ${signStr}`);

```

##### verifySegment performs segmented verification of data

```
let keyPair1 = await RSA.generateKeyPair(); //生成密钥

let str3 = "harmony-utils，一款高效的HarmonyOS工具包，封装了常用工具类，提供一系列简单易用的方法。帮助开发者快速构建鸿蒙应用。gitee地址：https://gitee.com/tongyuyan/harmony-utils。github主页地址：https://github.com/787107497。";
let data = CryptoHelper.strToUint8Array(str3, 'utf-8')；
let signDataBlob = await RSA.signSegment(data, keyPair.priKey);

let verify = await RSA.verifySegment(data, signDataBlob, keyPair.pubKey);
LogUtil.error(`分段验签，异步: ${verify}`);
```

##### recover signs the data and restores the original data. Currently only RSA supports it

```
let keyPair1 = await RSA.generateKeyPair(); //生成密钥

let str1 = "鸿蒙技术交流QQ群：1029219059";
let dataBlob = CryptoHelper.strToDataBlob(str1, 'utf-8');
let signDataBlob = RSA.signSync(dataBlob, keyPair.priKey, 'RSA1024|PKCS1|NoHash|OnlySign');

let recoverDataBlob = await RSA.recover(signDataBlob, keyPair.pubKey);
if (recoverDataBlob != null) {
  let recoverStr = CryptoHelper.dataBlobToStr(recoverDataBlob, 'utf-8');
  LogUtil.error(`签名恢复，异步: ${recoverStr}`);
} else {
  LogUtil.error(`签名恢复，异步: 恢复数据为空！`);
}
```

## Creation is not easy, please give Elder Tong a thumbs up 👍

------
[https://github.com/787107497/harmony-utils](https://github.com/787107497/harmony-utils)   
[https://gitee.com/tongyuyan/harmony-utils](https://gitee.com/tongyuyan/harmony-utils)   
[OpenHarmony三方库](https://ohpm.openharmony.cn/#/cn/detail/@pura%2Fharmony-utils)   
[童长老CSDN博客](https://blog.csdn.net/qq_32922545)   
   
