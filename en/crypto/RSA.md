# RSA, RSA is encrypted and decrypted

## Introduction and description of harmony-utils

------
[harmony-utils](https://ohpm.openharmony.cn/#/cn/detail/@pura%2Fharmony-utils)A HarmonyOS tool library with rich features and extremely easy to use, with the help of many practical tools, is committed to helping developers quickly build Hongmeng applications. Its encapsulated tools cover APP, device, screen, authorization, notification, inter-thread communication, pop-up frames, toast, biometric authentication, user preferences, taking photos, albums, scanning codes, files, logs, exception capture, characters, strings, numbers, collections, dates, random, base64, encryption, decryption, JSON and other functions, which can meet various development needs.
[picker_utils](https://ohpm.openharmony.cn/#/cn/detail/@pura%2Fpicker_utils)It is a sub-store split by harmony-utils, including PickerUtil, PhotoHelper, and ScanUtil.

Download and install
`ohpm i @pura/harmony-utils`  
`ohpm i @pura/picker_utils`

 ```
  //å…¨å±€åˆå§‹åŒ–æ–¹æ³•ï¼Œåœ¨UIAbilityçš„onCreateæ–¹æ³•ä¸­åˆå§‹åŒ– AppUtil.init()
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    AppUtil.init(this.context);
  }
 ```


## Introduction to RSA algorithm

------
RSA is an asymmetric encryption algorithm proposed in 1977. Based on the design of large-number decomposition problem, the key is divided into public key (e,n) and private key (d,n), where n is the product of two prime numbers and d is the modulo inverse element of e. During encryption, the plain text m is generated by c=m^e mod n, and when decrypting, m=c^d mod n is used. Its security depends on the calculation complexity of decomposing large numbers n, and is often used in scenarios such as HTTPS key transmission and digital signatures. However, due to low computing efficiency, it is not suitable for encrypting large amounts of data, and the 1024-bit key can be threatened by quantum computing. It is now recommended that keys above 2048-bit are the pioneering algorithm of the public key encryption system.

## RSA application scenarios

------
As an asymmetric encryption algorithm, RSA is corely used in scenarios where public key verification and private key confidentiality are required. In network communication, HTTPS uses it to encrypt symmetric session keys and PGP to encrypt emails; in the field of digital signatures, it covers software code signatures, blockchain transaction authentication and electronic document signatures; in key management, it supports SSH password-free login and VPN key negotiation; in financial scenarios, the bank U-shield and CA certificate systems rely on them to achieve identity authentication and resistance. Although the calculation overhead is large and not suitable for massive data encryption, it is indispensable in key secure transmission and signature authentication, and is the basic algorithm of the Internet security system.


## API methods and usage

------

##### generateKeyPair generates asymmetric key KeyPair

```
let keyPair1 = await RSA.generateKeyPair();
let pubKeyStr1 = CryptoHelper.dataBlobToStr(keyPair1.pubKey.getEncoded(), 'hex'); //å°†å…¬é’¥è½¬æ¢æˆbase64å­—ç¬¦ä¸²ã€‚
LogUtil.error(`pubKeyStr1: ${pubKeyStr1}`);
let priKeyStr1 = CryptoHelper.dataBlobToStr(keyPair1.priKey.getEncoded(), 'hex'); //å°†ç§é’¥è½¬æ¢æˆbase64ç¬¦ç¬¦ä¸²ã€‚
LogUtil.error(`priKeyStr1: ${priKeyStr1}`);
```

##### getConvertKeyPair Get the converted asymmetric key KeyPair

```
let pubKeyStr = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDUpsnavHoapoKtOOM9NKqTt6BpPe07ZzxhMcLAm5dtFQ6zRyJwT3czHGnh1BM2FATvLTDGLkmKc/Ww27//lFbrbqBE19R/5y8UPRpbUdACZ28yqzdiaquovUndhTH/CnLzcPM7VnWO0gp3/kbg5WizkZtUTRHL+Nu4OHbbesO1wIDAQAB"; //base64å­—ç¬¦ä¸²å¯†é’¥
let priKeyStr = "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAMNSmydq8ehqmgq044z00qpO3oGk97TtnPGExwsCbl20VDrNHInBPdzMcaeHUEzYUBO8tMMYuSYpz9bDbv/+UVutuoETX1H/nLxQ9GltR0AJnbzKrN2Jqq6i9Sd2FMf8KcvNw8ztWdY7SCnf+RuDlaLORm1RNEcv427g4dtt6w7XAgMBAAECgYANvgsii9i3VIDADhgQe80ypFftYTD4btti9seWU7Z2K1Ddzj6axpjWpx+7/L4+md2Qde915pBoSfrQjnGJ21fX7vpqOVdDWS7lseYfM50z8ZMpZewxJNBkSGYQEazMYDfyCFMjZmB4guf/uu0B2JN/YtA8Ed7JJlkXmVLh4ReYSQJBAOIhzozpcIuGOBjylQdN+MokiL14gnAh6hiwnusD9JlTSJbQonUXkhikaf0WphxBVPSngZDdi3FYla/CDUAScBMCQQDdHwsJZ1oShtbJltaUCEsJHTWLwYm8V8tTOpHGJU8/u1mBK3pVZlwnfzzrj2oLl5iBpMHF197TPNi5gjrjM6atAkA/4pMrBixQjqu8iJQHy0R1P1sORER9j2dGcGeFN8nbo0bHrMuozu7sXU7APKzTILXypHwbRCvH6uHnFKiPqGXXAkAUsjEgQjImBcTYvWt8E4Kiab93QzgXDsiTE6pNN3TBbFGmS2F52MjLUZdsHNI6H4hAqiEQ2XGbp9hJFK1aUp1JAkEAjP4fbqrAUjGiG+EbjEffV625kACb6q9Wz+vbspMPqcr5TU2AxxSW65Yilq4pKYq8O+qXnVdOpX7DjrWA1kg2JA=="; //base64å­—ç¬¦ä¸²å¯†é’¥
let keyPair1 = await RSA.getConvertKeyPair(pubKeyStr, priKeyStr, 'base64');
let keyPair2 = RSA.getConvertKeyPairSync(pubKeyStr, priKeyStr, 'base64');
```

##### encrypt encryption

```
let keyPair1 = await RSA.generateKeyPair(); //ç”Ÿæˆå¯†é’¥

let str1 = "é¸¿è’™æŠ€æœ¯äº¤æµQQç¾¤ï¼š1029219059";
let dataBlob = CryptoHelper.strToDataBlob(str1, 'utf-8'); //å¾…åŠ å¯†æ•°æ®

let encryptDataBlob = await RSA.encrypt(dataBlob, keyPair1.pubKey); //åŠ å¯†
let encryptStr = CryptoHelper.dataBlobToStr(encryptDataBlob, 'utf-8');
LogUtil.error(`åŠ å¯†ï¼Œå¼‚æ­¥ï¼š${encryptStr}`);
```

##### decrypt

```
let keyPair1 = await RSA.generateKeyPair(); //ç”Ÿæˆå¯†é’¥

let str1 = "é¸¿è’™æŠ€æœ¯äº¤æµQQç¾¤ï¼š1029219059";
let dataBlob = CryptoHelper.strToDataBlob(str1, 'utf-8'); //å¾…åŠ å¯†æ•°æ®

let encryptDataBlob = await RSA.encrypt(dataBlob, keyPair1.pubKey); //åŠ å¯†
let decryptDataBlob = await RSA.decrypt(encryptDataBlob, keyPair1.priKey); //è§£å¯†
let decryptStr = CryptoHelper.dataBlobToStr(decryptDataBlob, 'utf-8');
LogUtil.error(`è§£å¯†ï¼Œå¼‚æ­¥ï¼š${decryptStr}`);or(`åŠ è§£å¯†ï¼ŒåŒæ­¥ï¼š${decryptStr2}`);
```

##### encryptSegment encryption, segmentation

```
let keyPair1 = await RSA.generateKeyPair("RSA1024|PRIMES_2"); //ç”Ÿæˆå¯†é’¥

let str2 = "harmony-utilsï¼Œä¸€æ¬¾é«˜æ•ˆçš„HarmonyOSå·¥å…·åŒ…ï¼Œå°è£…äº†å¸¸ç”¨å·¥å…·ç±»ï¼Œæä¾›ä¸€ç³»åˆ—ç®€å•æ˜“ç”¨çš„æ–¹æ³•ã€‚å¸®åŠ©å¼€å‘è€…å¿«é€Ÿæ„å»ºé¸¿è’™åº”ç”¨ã€‚";
let dataBlob = CryptoHelper.strToDataBlob(str2, 'utf-8'); //å¾…åŠ å¯†æ•°æ®

let encryptDataBlob = await RSA.encryptSegment(dataBlob, keyPair1.pubKey, 'RSA2048|PKCS1'); //åŠ å¯†
let encryptStr = CryptoHelper.dataBlobToStr(encryptDataBlob, 'utf-8');
LogUtil.error(`åˆ†æ®µåŠ å¯†ï¼Œå¼‚æ­¥ï¼š${encryptStr}`);
```

##### decryptSegment decryption, segmentation

```
let keyPair1 = await RSA.generateKeyPair("RSA1024|PRIMES_2"); //ç”Ÿæˆå¯†é’¥

let str2 = "harmony-utilsï¼Œä¸€æ¬¾é«˜æ•ˆçš„HarmonyOSå·¥å…·åŒ…ï¼Œå°è£…äº†å¸¸ç”¨å·¥å…·ç±»ï¼Œæä¾›ä¸€ç³»åˆ—ç®€å•æ˜“ç”¨çš„æ–¹æ³•ã€‚å¸®åŠ©å¼€å‘è€…å¿«é€Ÿæ„å»ºé¸¿è’™åº”ç”¨ã€‚";
let dataBlob = CryptoHelper.strToDataBlob(str2, 'utf-8'); //å¾…åŠ å¯†æ•°æ®

let encryptDataBlob = await RSA.encryptSegment(dataBlob, keyPair1.pubKey, 'RSA2048|PKCS1'); //åŠ å¯†
let decryptDataBlob = await RSA.decryptSegment(encryptDataBlob, keyPair1.priKey, 'RSA2048|PKCS1'); //è§£å¯†
let decryptStr = CryptoHelper.dataBlobToStr(decryptDataBlob, 'utf-8');
LogUtil.error(`åˆ†æ®µè§£å¯†ï¼Œå¼‚æ­¥ï¼š${decryptStr}`);
```

##### sign Sign the data

```
let keyPair = await RSA.generateKeyPair(); //ç”Ÿæˆå¯†é’¥

let str1 = "é¸¿è’™æŠ€æœ¯äº¤æµQQç¾¤ï¼š1029219059";
let dataBlob = CryptoHelper.strToDataBlob(str1, 'utf-8');

let signDataBlob1 = await RSA.sign(dataBlob, keyPair.priKey);
let signStr1 = CryptoHelper.dataBlobToStr(signDataBlob1, 'hex');
LogUtil.error(`ç­¾åï¼Œå¼‚æ­¥: ${signStr1}`);
```

##### verify the data verification

```
let keyPair = await RSA.generateKeyPair(); //ç”Ÿæˆå¯†é’¥

let str1 = "é¸¿è’™æŠ€æœ¯äº¤æµQQç¾¤ï¼š1029219059";
let signDataBlob1 = await RSA.sign(dataBlob, keyPair.priKey);
let signStr1 = CryptoHelper.dataBlobToStr(signDataBlob1, 'hex');

let verify1 = await RSA.verify(dataBlob, signDataBlob1, keyPair!.pubKey);
LogUtil.error(`éªŒç­¾ï¼Œå¼‚æ­¥: ${verify1}`);
```

##### signSegment Signs the data in segmentation

```
let keyPair1 = await RSA.generateKeyPair(); //ç”Ÿæˆå¯†é’¥

let str3 = "harmony-utilsï¼Œä¸€æ¬¾é«˜æ•ˆçš„HarmonyOSå·¥å…·åŒ…ï¼Œå°è£…äº†å¸¸ç”¨å·¥å…·ç±»ï¼Œæä¾›ä¸€ç³»åˆ—ç®€å•æ˜“ç”¨çš„æ–¹æ³•ã€‚å¸®åŠ©å¼€å‘è€…å¿«é€Ÿæ„å»ºé¸¿è’™åº”ç”¨ã€‚giteeåœ°å€ï¼šhttps://gitee.com/tongyuyan/harmony-utilsã€‚githubä¸»é¡µåœ°å€ï¼šhttps://github.com/787107497ã€‚";
let data = CryptoHelper.strToUint8Array(str3, 'utf-8')ï¼›

let signDataBlob = await RSA.signSegment(data, keyPair.priKey);
let signStr = CryptoHelper.dataBlobToStr(signDataBlob, 'base64');
LogUtil.error(`åˆ†æ®µç­¾åï¼Œå¼‚æ­¥: ${signStr}`);

```

##### verifySegment performs segmented verification of data

```
let keyPair1 = await RSA.generateKeyPair(); //ç”Ÿæˆå¯†é’¥

let str3 = "harmony-utilsï¼Œä¸€æ¬¾é«˜æ•ˆçš„HarmonyOSå·¥å…·åŒ…ï¼Œå°è£…äº†å¸¸ç”¨å·¥å…·ç±»ï¼Œæä¾›ä¸€ç³»åˆ—ç®€å•æ˜“ç”¨çš„æ–¹æ³•ã€‚å¸®åŠ©å¼€å‘è€…å¿«é€Ÿæ„å»ºé¸¿è’™åº”ç”¨ã€‚giteeåœ°å€ï¼šhttps://gitee.com/tongyuyan/harmony-utilsã€‚githubä¸»é¡µåœ°å€ï¼šhttps://github.com/787107497ã€‚";
let data = CryptoHelper.strToUint8Array(str3, 'utf-8')ï¼›
let signDataBlob = await RSA.signSegment(data, keyPair.priKey);

let verify = await RSA.verifySegment(data, signDataBlob, keyPair.pubKey);
LogUtil.error(`åˆ†æ®µéªŒç­¾ï¼Œå¼‚æ­¥: ${verify}`);
```

##### recover signs the data and restores the original data. Currently only RSA supports it

```
let keyPair1 = await RSA.generateKeyPair(); //ç”Ÿæˆå¯†é’¥

let str1 = "é¸¿è’™æŠ€æœ¯äº¤æµQQç¾¤ï¼š1029219059";
let dataBlob = CryptoHelper.strToDataBlob(str1, 'utf-8');
let signDataBlob = RSA.signSync(dataBlob, keyPair.priKey, 'RSA1024|PKCS1|NoHash|OnlySign');

let recoverDataBlob = await RSA.recover(signDataBlob, keyPair.pubKey);
if (recoverDataBlob != null) {
  let recoverStr = CryptoHelper.dataBlobToStr(recoverDataBlob, 'utf-8');
  LogUtil.error(`ç­¾åæ¢å¤ï¼Œå¼‚æ­¥: ${recoverStr}`);
} else {
  LogUtil.error(`ç­¾åæ¢å¤ï¼Œå¼‚æ­¥: æ¢å¤æ•°æ®ä¸ºç©ºï¼`);
}
```

## Creation is not easy, please give Elder Tong a thumbs up ğŸ‘

------
[https://github.com/787107497/harmony-utils](https://github.com/787107497/harmony-utils)   
[https://gitee.com/tongyuyan/harmony-utils](https://gitee.com/tongyuyan/harmony-utils)   
[OpenHarmonyä¸‰æ–¹åº“](https://ohpm.openharmony.cn/#/cn/detail/@pura%2Fharmony-utils)   
[ç«¥é•¿è€CSDNåšå®¢](https://blog.csdn.net/qq_32922545)   
   
